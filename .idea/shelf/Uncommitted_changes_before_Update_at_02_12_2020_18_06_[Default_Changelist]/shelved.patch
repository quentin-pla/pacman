Index: src/main/java/gameplay/Gameplay.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package gameplay;\r\n\r\nimport engines.AI.AIEngine;\r\nimport engines.graphics.Color;\r\nimport engines.graphics.GraphicEntity;\r\nimport engines.graphics.GraphicsEngine;\r\nimport engines.graphics.Scene;\r\nimport engines.input_output.IOEngine;\r\nimport engines.kernel.Entity;\r\nimport engines.kernel.KernelEngine;\r\nimport engines.physics.PhysicEntity;\r\nimport engines.physics.PhysicsEngine;\r\nimport engines.sound.SoundEngine;\r\n\r\nimport javax.sound.sampled.LineEvent;\r\nimport java.awt.event.KeyEvent;\r\nimport java.util.*;\r\n\r\nimport static java.lang.Thread.sleep;\r\n\r\n/**\r\n * Gameplay\r\n */\r\npublic class Gameplay {\r\n    /**\r\n     * Directions de déplacement\r\n     */\r\n    public enum MoveDirection {\r\n        UP,RIGHT,DOWN,LEFT\r\n    }\r\n\r\n    /**\r\n     * Moteur noyau\r\n     */\r\n    private final KernelEngine kernelEngine;\r\n\r\n    /**\r\n     * Identifiant du fichier contenant les textures du jeu\r\n     */\r\n    private final int textures;\r\n\r\n    /**\r\n     * Scène menu principal\r\n     */\r\n    private Scene menuView;\r\n\r\n    /**\r\n     * Scène fin de jeu\r\n     */\r\n    private Scene endGameView;\r\n\r\n    /**\r\n     * Niveaux disponibles\r\n     */\r\n    private ArrayList<Level> levels;\r\n\r\n    /**\r\n     * Niveau courant\r\n     */\r\n    private Level currentLevel;\r\n\r\n    /**\r\n     * Affichage du volume\r\n     */\r\n    private Entity currentVolume;\r\n    /**\r\n     * Joueur\r\n     */\r\n    private Pacman pacman;\r\n\r\n    private HashMap<String,Entity> targets = new HashMap<String,Entity>();\r\n\r\n    /**\r\n     * Fantomes\r\n     */\r\n    private Map<String,Ghost> ghosts;\r\n\r\n    /**\r\n     * Booléen pour savoir si les fantômes sont appeurés\r\n     */\r\n    private volatile boolean ghostFear;\r\n\r\n    /**\r\n     * Constructeur\r\n     */\r\n    public Gameplay() {\r\n        this.kernelEngine = new KernelEngine();\r\n        this.textures = kernelEngine.getGraphicsEngine().loadSpriteSheet(\"assets/sprite_sheet.png\", 12, 11);\r\n        this.levels = new ArrayList<>();\r\n        this.ghostFear = false;\r\n        initGameplay();\r\n    }\r\n\r\n    /**\r\n     * Initialiser le gameplay\r\n     */\r\n    private void initGameplay() {\r\n        //Activation des entrées / sorties\r\n        ioEngine().enableKeyboardIO();\r\n        ioEngine().enableMouseIO();\r\n        //Initialiser les joueurs\r\n        initPlayers();\r\n        //Initialiser les évènements\r\n        initEvents();\r\n        //Initialiser les sons\r\n        initSounds();\r\n        //Initialiser le menu\r\n        initMenu();\r\n        //Initialiser la vue de fin de jeu\r\n        initEndGameView();\r\n        //Initialiser le niveau par défaut\r\n        initDefaultLevel();\r\n    }\r\n\r\n    /**\r\n     * Initialiser les évènements du jeu\r\n     */\r\n    private void initEvents() {\r\n        //Jouer un niveau\r\n        kernelEngine.addEvent(\"playLevel\", () -> playLevel(levels.get(0)));\r\n        //Jouer une nouvelle partie\r\n        kernelEngine.addEvent(\"newGame\", () -> {\r\n            levels.remove(currentLevel);\r\n            initDefaultLevel();\r\n            playLevel(levels.get(0));\r\n        });\r\n        //Déplacer le fantome rose\r\n        kernelEngine.addEvent(\"movePinkGhost\", this::applyPinkGhostAI);\r\n        //Déplacer le fantome rouge\r\n        kernelEngine.addEvent(\"moveRedGhost\", this::applyPinkGhostAI);\r\n        //Déplacer le fantome Bleu\r\n        kernelEngine.addEvent(\"moveBlueGhost\", this::applyBlueGhostAI);\r\n        //Se déplacer vers le haut\r\n        kernelEngine.addEvent(\"pacmanGoUp\", () -> switchPacmanDirection(MoveDirection.UP));\r\n        //Se déplacer vers la droite\r\n        kernelEngine.addEvent(\"pacmanGoRight\", () -> switchPacmanDirection(MoveDirection.RIGHT));\r\n        //Se déplacer vers le bas\r\n        kernelEngine.addEvent(\"pacmanGoDown\", () -> switchPacmanDirection(MoveDirection.DOWN));\r\n        //Se déplacer vers la gauche\r\n        kernelEngine.addEvent(\"pacmanGoLeft\", () -> switchPacmanDirection(MoveDirection.LEFT));\r\n        //Augmenter le volume\r\n        kernelEngine.addEvent(\"augmentVolume\", this::incrementGlobalVolume);\r\n        //Baisser le volume\r\n        kernelEngine.addEvent(\"downVolume\", this::decrementGlobalVolume);\r\n        //Lorsqu'il y a une collision\r\n\r\n        kernelEngine.addEvent(\"pacmanOnCollision\", this::checkPacmanCollisions);\r\n\r\n\r\n\r\n        //Liaison des évènements du niveau\r\n        ioEngine().bindEventOnLastKey(KeyEvent.VK_UP, \"pacmanGoUp\");\r\n        ioEngine().bindEventOnLastKey(KeyEvent.VK_RIGHT, \"pacmanGoRight\");\r\n        ioEngine().bindEventOnLastKey(KeyEvent.VK_DOWN, \"pacmanGoDown\");\r\n        ioEngine().bindEventOnLastKey(KeyEvent.VK_LEFT, \"pacmanGoLeft\");\r\n        physicsEngine().bindEventOnCollision(pacman, \"pacmanOnCollision\");\r\n        aiEngine().bindEvent(ghosts.get(\"pink\"), \"movePinkGhost\");\r\n        aiEngine().bindEvent(ghosts.get(\"blue\"), \"moveBlueGhost\");\r\n    }\r\n\r\n    /**\r\n     * Initialiser les sons du jeu\r\n     */\r\n    private void initSounds() {\r\n        soundEngine().loadSound(\"munch_1.wav\",\"munch1\");\r\n        soundEngine().loadSound(\"munch_2.wav\",\"munch2\");\r\n        soundEngine().loadSound(\"game_start.wav\",\"gameStart\");\r\n        soundEngine().loadSound(\"death_1.wav\",\"death_1\");\r\n        soundEngine().loadSound(\"death_2.wav\",\"death_2\");\r\n\r\n        soundEngine().setGlobalVolume(0);\r\n    }\r\n\r\n    /**\r\n     * Initialiser le menu\r\n     */\r\n    private void initMenu() {\r\n        menuView = graphicsEngine().generateScene(400,400);\r\n        Entity button = kernelEngine.generateEntity();\r\n        Entity volumePlus = kernelEngine.generateEntity();\r\n        Entity volumeMinus = kernelEngine.generateEntity();\r\n        currentVolume = kernelEngine.generateEntity();\r\n\r\n        physicsEngine().resize(volumePlus,50,25);\r\n        physicsEngine().move(volumePlus, 20,350);\r\n        graphicsEngine().bindColor(volumePlus,50,50,50);\r\n        graphicsEngine().bindText(volumePlus, \"-\", new Color(255,255,255), 20, true);\r\n        graphicsEngine().addToScene(menuView, volumePlus);\r\n        ioEngine().bindEventOnClick(volumePlus,\"downVolume\");\r\n\r\n        physicsEngine().resize(volumeMinus,50,25);\r\n        physicsEngine().move(volumeMinus, 330,350);\r\n        graphicsEngine().bindColor(volumeMinus,50,50,50);\r\n        graphicsEngine().bindText(volumeMinus, \"+\", new Color(255,255,255), 20, true);\r\n        graphicsEngine().addToScene(menuView, volumeMinus);\r\n        ioEngine().bindEventOnClick(volumeMinus,\"augmentVolume\");\r\n\r\n        physicsEngine().resize(currentVolume,200,50);\r\n        physicsEngine().move(currentVolume, 100,337);\r\n        graphicsEngine().bindColor(currentVolume,50,50,50);\r\n        graphicsEngine().bindText(currentVolume, \"Volume is : \" + (int) soundEngine().getGlobalvolume()*100, new Color(255,255,255), 20, true);\r\n        graphicsEngine().addToScene(menuView, currentVolume);\r\n\r\n        physicsEngine().resize(button,100,50);\r\n        physicsEngine().move(button, 150,240);\r\n        graphicsEngine().bindColor(button,50,50,50);\r\n        graphicsEngine().bindText(button, \"PLAY\", new Color(255,255,255), 20, true);\r\n        graphicsEngine().addToScene(menuView, button);\r\n        ioEngine().bindEventOnClick(button,\"playLevel\");\r\n\r\n        Entity menuLogo = kernelEngine.generateEntity();\r\n        int logoTexture = kernelEngine.getGraphicsEngine().loadTexture(\"assets/menu_logo.png\");\r\n        physicsEngine().resize(menuLogo,300,71);\r\n        physicsEngine().move(menuLogo, 50,120);\r\n        graphicsEngine().bindTexture(menuLogo,logoTexture);\r\n        graphicsEngine().addToScene(menuView, menuLogo);\r\n\r\n    }\r\n\r\n    /**\r\n     * Initialiser la page en fin de jeu\r\n     */\r\n    private void initEndGameView() {\r\n        endGameView = graphicsEngine().generateScene(400,400);\r\n\r\n        Entity youLost = kernelEngine.generateEntity();\r\n        physicsEngine().resize(youLost,100,50);\r\n        physicsEngine().move(youLost, 150,50);\r\n        graphicsEngine().bindText(youLost, \"YOU LOST !\", new Color(255,50,0), 25, true);\r\n        graphicsEngine().addToScene(endGameView, youLost);\r\n\r\n        Entity score = kernelEngine.generateEntity();\r\n        physicsEngine().resize(score,200,50);\r\n        physicsEngine().move(score, 100,150);\r\n        graphicsEngine().addToScene(endGameView, score);\r\n\r\n        Entity newGame = kernelEngine.generateEntity();\r\n        physicsEngine().resize(newGame,200,50);\r\n        physicsEngine().move(newGame, 100,240);\r\n        graphicsEngine().bindColor(newGame,50,50,50);\r\n        graphicsEngine().bindText(newGame, \"NEW GAME\", new Color(255,255,255), 20, true);\r\n        graphicsEngine().addToScene(endGameView, newGame);\r\n        ioEngine().bindEventOnClick(newGame,\"newGame\");\r\n    }\r\n\r\n    /**\r\n     * Initialiser les joueurs\r\n     */\r\n    private void initPlayers() {\r\n        pacman = new Pacman(this);\r\n        ghosts = new HashMap<>();\r\n        ghosts.put(\"red\", new Ghost(this, \"red\"));\r\n        ghosts.put(\"blue\", new Ghost(this, \"blue\"));\r\n        ghosts.put(\"pink\", new Ghost(this, \"pink\"));\r\n        ghosts.put(\"orange\", new Ghost(this, \"orange\"));\r\n    }\r\n\r\n    /**\r\n     * Initialiser le niveau par défaut\r\n     */\r\n    private void initDefaultLevel() {\r\n        //Level par défaut\r\n        Level defaultLevel = generateLevel(21,19);\r\n\r\n        //Génération des murs\r\n        Map<Integer,int[]> wallRows = new HashMap<>();\r\n\r\n        wallRows.put(0, new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18});\r\n        wallRows.put(1, new int[]{0, 9, 18});\r\n        wallRows.put(2, new int[]{0, 2, 3, 5, 6, 7, 9, 11, 12, 13, 15, 16, 18});\r\n        wallRows.put(3, new int[]{0, 18});\r\n        wallRows.put(4, new int[]{0, 2, 3, 5, 7, 8, 9, 10, 11, 13, 15, 16, 18});\r\n        wallRows.put(5, new int[]{0, 5, 9, 13, 18});\r\n        wallRows.put(6, new int[]{0, 1, 2, 3, 5, 6, 7, 9, 11, 12, 13, 15, 16, 17, 18});\r\n        wallRows.put(7, new int[]{3, 5, 13, 15});\r\n        wallRows.put(8, new int[]{0, 1, 2, 3, 5, 7, 8, 10, 11, 13, 15, 16, 17, 18});\r\n        wallRows.put(9, new int[]{7, 11});\r\n        wallRows.put(10, new int[]{0, 1, 2, 3, 5, 7, 8, 9, 10, 11, 13, 15, 16, 17, 18});\r\n        wallRows.put(11, new int[]{3, 5, 13, 15});\r\n        wallRows.put(12, new int[]{0, 1, 2, 3, 5, 7, 8, 9, 10, 11, 13, 15, 16, 17, 18});\r\n        wallRows.put(13, new int[]{0, 9, 18});\r\n        wallRows.put(14, new int[]{0, 2, 3, 5, 6, 7, 9, 11, 12, 13, 15, 16, 18});\r\n        wallRows.put(15, new int[]{0, 3, 15, 18});\r\n        wallRows.put(16, new int[]{0, 1, 3, 5, 7, 8, 9, 10, 11, 13, 15, 17, 18});\r\n        wallRows.put(17, new int[]{0, 5, 9, 13, 18});\r\n        wallRows.put(18, new int[]{0, 2, 3, 4, 5, 6, 7, 9, 11, 12, 13, 14, 15, 16, 18});\r\n        wallRows.put(19, new int[]{0, 18});\r\n        wallRows.put(20, new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18});\r\n\r\n        for (Map.Entry<Integer,int[]> row : wallRows.entrySet())\r\n            for (int col : row.getValue())\r\n                defaultLevel.addWall(row.getKey(),col);\r\n\r\n        defaultLevel.applyWallTextures();\r\n\r\n        //Génération des balles\r\n        Map<Integer,int[]> ballRows = new HashMap<>();\r\n\r\n        ballRows.put(1, new int[]{2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 16});\r\n        ballRows.put(2, new int[]{1, 4, 8, 10, 14, 17});\r\n        ballRows.put(3, new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17});\r\n        ballRows.put(4, new int[]{1, 4, 6, 12, 14, 17});\r\n        ballRows.put(5, new int[]{1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14, 15, 16, 17});\r\n        ballRows.put(6, new int[]{4, 8, 10, 14});\r\n        ballRows.put(7, new int[]{4, 6, 7, 8, 9, 10, 11, 12, 14});\r\n        ballRows.put(8, new int[]{4, 6, 12, 14});\r\n        ballRows.put(9, new int[]{4, 5, 6, 12, 13, 14});\r\n        ballRows.put(10, new int[]{4, 6, 12, 14});\r\n        ballRows.put(11, new int[]{4, 6, 7, 8, 9, 10, 11, 12, 14});\r\n        ballRows.put(12, new int[]{4, 6, 12, 14});\r\n        ballRows.put(13, new int[]{1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 16, 17});\r\n        ballRows.put(14, new int[]{1, 4, 8, 10, 14, 17});\r\n        ballRows.put(15, new int[]{1, 2, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 16, 17});\r\n        ballRows.put(16, new int[]{2, 4, 6, 12, 14, 16});\r\n        ballRows.put(17, new int[]{1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 14, 15, 16, 17});\r\n        ballRows.put(18, new int[]{1, 8, 10, 17});\r\n        ballRows.put(19, new int[]{2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16});\r\n\r\n\r\n\r\n        for (Map.Entry<Integer,int[]> row : ballRows.entrySet())\r\n            for (int col : row.getValue())\r\n                defaultLevel.addBall(row.getKey(),col);\r\n\r\n        //Ajout de la barrière\r\n        defaultLevel.addFence(8, 9);\r\n\r\n        defaultLevel.addGomme(1,1);\r\n        defaultLevel.addGomme(19,1);\r\n\r\n        // Ajout des super gommes\r\n        defaultLevel.addGomme(1,17);\r\n        defaultLevel.addGomme(19,17);\r\n\r\n        //ajout target pour scatter (patrouille)\r\n        targets.put(\"TopLeft\", defaultLevel.addTarget(1,1));\r\n        targets.put(\"TopRight\",defaultLevel.addTarget(1,17));\r\n        targets.put(\"BottomLeft\",defaultLevel.addTarget(19,1));\r\n        targets.put(\"BottomRight\",defaultLevel.addTarget(19,17));\r\n    }\r\n\r\n    private void reachTarget(Ghost ghost,PhysicEntity target){\r\n\r\n        PhysicEntity ghostPhysic = ghost.getPhysicEntity();\r\n        Set<MoveDirection> forbiddenDirections = ghost.getForbiddenDirection();\r\n\r\n        //Calcul de la distance horizontale et verticale entre pacman et le fantome\r\n        int playerXmiddle = (target.getX() + target.getWidth()) / 2;\r\n        int playerYmiddle = (target.getY() + target.getHeight()) / 2;\r\n        int ghostXmiddle = (ghostPhysic.getX() + ghostPhysic.getWidth()) / 2;\r\n        int ghostYmiddle = (ghostPhysic.getY() + ghostPhysic.getHeight()) / 2;\r\n        int xDistance = playerXmiddle - ghostXmiddle;\r\n        int yDistance = playerYmiddle - ghostYmiddle;\r\n\r\n        //Définition des directions horizontales et verticales\r\n        MoveDirection xDirection = xDistance == 0 ? null\r\n                : xDistance < 0 ? MoveDirection.LEFT : MoveDirection.RIGHT;\r\n        MoveDirection yDirection = yDistance == 0 ? null\r\n                : yDistance < 0 ? MoveDirection.UP : MoveDirection.DOWN;\r\n\r\n        //Définition de la prochaine direction\r\n        MoveDirection nextDirection = Math.abs(xDistance) > Math.abs(yDistance) ? xDirection : yDirection;\r\n\r\n        //Vérification des collisions\r\n        boolean somethingUP     = physicsEngine().isSomethingUp(ghost) != null;\r\n        boolean somethingRIGHT  = physicsEngine().isSomethingRight(ghost) != null;\r\n        boolean somethingDOWN   = physicsEngine().isSomethingDown(ghost) != null;\r\n        boolean somethingLEFT   = physicsEngine().isSomethingLeft(ghost) != null;\r\n\r\n        //Détermination de la prochaine direction\r\n        if (Math.abs(xDistance) <= 1 && Math.abs(yDistance) <= 1) {\r\n            ghost.setCurrentDirection(null);\r\n        } else if (nextDirection == MoveDirection.UP && !forbiddenDirections.contains(MoveDirection.UP) && !somethingUP) {\r\n            ghost.setCurrentDirection(MoveDirection.UP);\r\n            forbiddenDirections.clear();\r\n        } else if (nextDirection == MoveDirection.DOWN && !forbiddenDirections.contains(MoveDirection.DOWN) && !somethingDOWN) {\r\n            ghost.setCurrentDirection(MoveDirection.DOWN);\r\n            forbiddenDirections.clear();\r\n        } else if (nextDirection == MoveDirection.LEFT && !forbiddenDirections.contains(MoveDirection.LEFT) && !somethingLEFT) {\r\n            ghost.setCurrentDirection(MoveDirection.LEFT);\r\n            forbiddenDirections.clear();\r\n        } else if (nextDirection == MoveDirection.RIGHT && !forbiddenDirections.contains(MoveDirection.RIGHT) && !somethingRIGHT) {\r\n            ghost.setCurrentDirection(MoveDirection.RIGHT);\r\n            forbiddenDirections.clear();\r\n        } else {\r\n            if (nextDirection == MoveDirection.UP || nextDirection == MoveDirection.DOWN) {\r\n                if (forbiddenDirections.size() == 1 && forbiddenDirections.contains(nextDirection))\r\n                    if (!somethingUP && nextDirection == MoveDirection.UP\r\n                            || !somethingDOWN && nextDirection == MoveDirection.DOWN)\r\n                        forbiddenDirections.clear();\r\n\r\n                if (somethingRIGHT) forbiddenDirections.add(MoveDirection.RIGHT);\r\n                if (somethingLEFT) forbiddenDirections.add(MoveDirection.LEFT);\r\n\r\n                if (xDirection != null && !forbiddenDirections.contains(xDirection)) {\r\n                    ghost.setCurrentDirection(xDirection);\r\n                    forbiddenDirections.add(xDirection == MoveDirection.LEFT ? MoveDirection.RIGHT : MoveDirection.LEFT);\r\n                } else if (!forbiddenDirections.contains(MoveDirection.LEFT)) {\r\n                    ghost.setCurrentDirection(MoveDirection.LEFT);\r\n                    forbiddenDirections.add(MoveDirection.RIGHT);\r\n                } else if (!forbiddenDirections.contains(MoveDirection.RIGHT)) {\r\n                    ghost.setCurrentDirection(MoveDirection.RIGHT);\r\n                    forbiddenDirections.add(MoveDirection.LEFT);\r\n                } else {\r\n                    boolean removeXDirections = false;\r\n                    if (xDirection != null)\r\n                        ghost.setCurrentDirection(xDirection);\r\n                    else if (nextDirection == MoveDirection.UP) {\r\n                        forbiddenDirections.add(MoveDirection.UP);\r\n                        if (!somethingDOWN) ghost.setCurrentDirection(MoveDirection.DOWN);\r\n                        else removeXDirections = true;\r\n                    } else {\r\n                        forbiddenDirections.add(MoveDirection.DOWN);\r\n                        if (!somethingUP) ghost.setCurrentDirection(MoveDirection.UP);\r\n                        else removeXDirections = true;\r\n                    }\r\n                    if (removeXDirections)\r\n                        forbiddenDirections.removeAll(Arrays.asList(MoveDirection.LEFT,MoveDirection.RIGHT));\r\n                }\r\n            }\r\n            else if (nextDirection == MoveDirection.LEFT || nextDirection == MoveDirection.RIGHT) {\r\n                if (forbiddenDirections.size() == 1 && forbiddenDirections.contains(nextDirection)) {\r\n                    if (!somethingLEFT && nextDirection == MoveDirection.LEFT)\r\n                        forbiddenDirections.clear();\r\n                    else if (!somethingRIGHT && nextDirection == MoveDirection.RIGHT)\r\n                        forbiddenDirections.clear();\r\n                }\r\n\r\n                if (somethingUP) forbiddenDirections.add(MoveDirection.UP);\r\n                if (somethingDOWN) forbiddenDirections.add(MoveDirection.DOWN);\r\n\r\n                if (yDirection != null && !forbiddenDirections.contains(yDirection)) {\r\n                    ghost.setCurrentDirection(yDirection);\r\n                    forbiddenDirections.add(yDirection == MoveDirection.UP ? MoveDirection.DOWN : MoveDirection.UP);\r\n                }\r\n                else if (!forbiddenDirections.contains(MoveDirection.UP)) {\r\n                    ghost.setCurrentDirection(MoveDirection.UP);\r\n                    forbiddenDirections.add(MoveDirection.DOWN);\r\n                } else if (!forbiddenDirections.contains(MoveDirection.DOWN)) {\r\n                    ghost.setCurrentDirection(MoveDirection.DOWN);\r\n                    forbiddenDirections.add(MoveDirection.UP);\r\n                } else {\r\n                    boolean removeYDirections = false;\r\n                    if (yDirection != null) ghost.setCurrentDirection(yDirection);\r\n                    else if (nextDirection == MoveDirection.LEFT) {\r\n                        forbiddenDirections.add(MoveDirection.LEFT);\r\n                        if (!somethingRIGHT) ghost.setCurrentDirection(MoveDirection.RIGHT);\r\n                        else removeYDirections = true;\r\n                    } else {\r\n                        forbiddenDirections.add(MoveDirection.RIGHT);\r\n                        if (!somethingLEFT) ghost.setCurrentDirection(MoveDirection.LEFT);\r\n                        else removeYDirections = true;\r\n                    }\r\n                    if (removeYDirections)\r\n                        forbiddenDirections.removeAll(Arrays.asList(MoveDirection.UP, MoveDirection.DOWN));\r\n                }\r\n            }\r\n        }\r\n        if (forbiddenDirections.size() == 4) forbiddenDirections.clear();\r\n        if (ghost.getCurrentDirection() != null) {\r\n            callEventFromDirection(ghost, ghost.getCurrentDirection());\r\n            graphicsEngine().bindAnimation(ghost, ghost.getAnimations().get(ghost.getCurrentDirection().name()));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Appliquer l'intelligence artificielle au fantome rose\r\n     */\r\n    private void applyPinkGhostAI() {\r\n        Ghost ghost = ghosts.get(\"red\");\r\n        PhysicEntity playerPhysic = pacman.getPhysicEntity();\r\n        reachTarget(ghost,playerPhysic);\r\n    }\r\n\r\n\r\n    protected void applyBlueGhostAI() {\r\n\r\n        Ghost ghost = ghosts.get(\"blue\");\r\n\r\n        //setting new patrol zone depending on score\r\n        if(currentLevel.getActualScore() == 0){\r\n            ghost.getScatterPatrolZones().put(\"TopRight\",false);\r\n            ghost.getScatterPatrolZones().put(\"TopLeft\",false);\r\n            ghost.getScatterPatrolZones().put(\"BottomRight\",true);\r\n            ghost.getScatterPatrolZones().put(\"BottomLeft\",false);\r\n            ghost.setPatroleZoneReached(false);\r\n        }else if(currentLevel.getActualScore() == 350){\r\n            ghost.getScatterPatrolZones().put(\"TopRight\",false);\r\n            ghost.getScatterPatrolZones().put(\"TopLeft\",false);\r\n            ghost.getScatterPatrolZones().put(\"BottomRight\",false);\r\n            ghost.getScatterPatrolZones().put(\"BottomLeft\",true);\r\n            ghost.setPatroleZoneReached(false);\r\n        }else if(currentLevel.getActualScore() == 700){\r\n            ghost.getScatterPatrolZones().put(\"TopRight\",true);\r\n            ghost.getScatterPatrolZones().put(\"TopLeft\",false);\r\n            ghost.getScatterPatrolZones().put(\"BottomRight\",false);\r\n            ghost.getScatterPatrolZones().put(\"BottomLeft\",false);\r\n            ghost.setPatroleZoneReached(false);\r\n        }else if (currentLevel.getActualScore() == 1200){\r\n            ghost.getScatterPatrolZones().put(\"TopRight\",false);\r\n            ghost.getScatterPatrolZones().put(\"TopLeft\",true);\r\n            ghost.getScatterPatrolZones().put(\"BottomRight\",false);\r\n            ghost.getScatterPatrolZones().put(\"BottomLeft\",false);\r\n            ghost.setPatroleZoneReached(false);\r\n        }\r\n\r\n        //vérifie si on a atteint la zone de patrouille\r\n        if (!ghost.isPatroleZoneReached()){\r\n\r\n            //on enregistre la position du fantome\r\n            PhysicEntity ghostPhysic = ghost.getPhysicEntity();\r\n            int ghostX = ghostPhysic.getX();\r\n            int ghostY = ghostPhysic.getY();\r\n\r\n            //on décide de l'endroit ou aller en fonction de la zone visée\r\n            if (ghost.getScatterPatrolZones().get(\"TopRight\")){\r\n                //on récupère l'entité cible qui est en l'occurence dans le coin haut droit\r\n                PhysicEntity targetTopRight = targets.get(\"TopRight\").getPhysicEntity();\r\n                //pn cherche a rejoindre cette cible\r\n                reachTarget(ghost,targetTopRight);\r\n                //si on atteint la cible, donc que les coordonnées sont les memes, on passe a la suite\r\n                int targetX = (targetTopRight.getX());\r\n                int targetY = (targetTopRight.getY());\r\n                if ((ghostX <= (targetX+4)) && (ghostX >= (targetX-4)) && (ghostY <= (targetY+4)) && (ghostY >= (targetY-4))){\r\n                    ghost.setPatroleZoneReached(true);\r\n                }\r\n                return;\r\n            }\r\n            else if (ghost.getScatterPatrolZones().get(\"TopLeft\")){\r\n                PhysicEntity targetTopLeft = targets.get(\"TopLeft\").getPhysicEntity();\r\n                reachTarget(ghost,targetTopLeft);\r\n                int targetX = (targetTopLeft.getX());\r\n                int targetY = (targetTopLeft.getY());\r\n                if ((ghostX <= (targetX+4)) && (ghostX >= (targetX-4)) && (ghostY <= (targetY+4)) && (ghostY >= (targetY-4))){\r\n                    ghost.setPatroleZoneReached(true);\r\n                }\r\n                return;\r\n            }\r\n            else if (ghost.getScatterPatrolZones().get(\"BottomRight\")){\r\n\r\n                PhysicEntity targetBottomRight = targets.get(\"BottomRight\").getPhysicEntity();\r\n                reachTarget(ghost,targetBottomRight);\r\n                int targetX = (targetBottomRight.getX());\r\n                int targetY = (targetBottomRight.getY());\r\n\r\n                /*System.out.println(targetX+4);\r\n                System.out.println(targetX-4);\r\n                System.out.println(ghostX);\r\n                System.out.println(targetY+4);\r\n                System.out.println(targetY-4);\r\n                System.out.println(ghostY);*/\r\n                if ((ghostX <= (targetX+4)) && (ghostX >= (targetX-4)) && (ghostY <= (targetY+4)) && (ghostY >= (targetY-4))){\r\n                    System.out.println(\"pass\");\r\n                    ghost.setPatroleZoneReached(true);\r\n                    System.out.println(ghost.isPatroleZoneReached());\r\n                }\r\n                return;\r\n            }\r\n            else if (ghost.getScatterPatrolZones().get(\"BottomLeft\")){\r\n                PhysicEntity targetBottomLeft = targets.get(\"BottomLeft\").getPhysicEntity();\r\n                reachTarget(ghost,targetBottomLeft);\r\n                int targetX = (targetBottomLeft.getX());\r\n                int targetY = (targetBottomLeft.getY());\r\n\r\n                if ((ghostX <= (targetX+4)) && (ghostX >= (targetX-4)) && (ghostY <= (targetY+4)) && (ghostY >= (targetY-4))){\r\n                    ghost.setPatroleZoneReached(true);\r\n                }\r\n                return;\r\n            }\r\n        } else {\r\n            //une fois dans la zone on patrouille au hasard\r\n            ghost.setCurrentDirection(updateGhostDirectionWithRandomness(ghost));\r\n        }\r\n        if (ghost.getCurrentDirection() != null) {\r\n            callEventFromDirection(ghost, ghost.getCurrentDirection());\r\n            graphicsEngine().bindAnimation(ghost, ghost.getAnimations().get(ghost.getCurrentDirection().name()));\r\n        }\r\n    }\r\n\r\n    protected MoveDirection updateGhostDirectionWithRandomness(Ghost ghost) {\r\n        boolean somethingUP     = physicsEngine().isSomethingUp(ghost) != null;\r\n        boolean somethingRIGHT  = physicsEngine().isSomethingRight(ghost) != null;\r\n        boolean somethingDOWN   = physicsEngine().isSomethingDown(ghost) != null;\r\n        boolean somethingLEFT   = physicsEngine().isSomethingLeft(ghost) != null;\r\n\r\n        int nombreAleatoire = 1 + (int)(Math.random() * ((4 - 1) + 1));\r\n        HashMap<String,Boolean> keepDirection = ghost.getKeepDirection() ;\r\n        System.out.println(nombreAleatoire);\r\n\r\n        if (keepDirection.get(\"KeepUp\") && somethingLEFT && somethingRIGHT && !somethingUP){\r\n            ghost.setPreviousDirection(MoveDirection.UP);\r\n            return MoveDirection.UP;\r\n        }\r\n        else if (keepDirection.get(\"KeepDown\") && somethingLEFT && somethingRIGHT && !somethingDOWN){\r\n            ghost.setPreviousDirection(MoveDirection.DOWN);\r\n            return MoveDirection.DOWN;\r\n        }\r\n        else if (keepDirection.get(\"KeepRight\") && somethingUP && somethingDOWN && !somethingRIGHT){\r\n            ghost.setPreviousDirection(MoveDirection.RIGHT);\r\n            return MoveDirection.RIGHT;\r\n        }\r\n        else if (keepDirection.get(\"KeepLeft\") && somethingUP && somethingDOWN && !somethingLEFT){\r\n            ghost.setPreviousDirection(MoveDirection.LEFT);\r\n            return MoveDirection.LEFT;\r\n        }\r\n        ghost.getKeepDirection().put(\"KeepUp\",false);\r\n        ghost.getKeepDirection().put(\"KeepRight\",false);\r\n        ghost.getKeepDirection().put(\"KeepDown\",false);\r\n        ghost.getKeepDirection().put(\"KeepLeft\",false);\r\n\r\n        if (nombreAleatoire == 1 && !somethingUP && ghost.getPreviousDirection() != MoveDirection.DOWN){\r\n            ghost.getKeepDirection().put(\"KeepUp\",true);\r\n            ghost.setPreviousDirection(MoveDirection.UP);\r\n            return MoveDirection.UP;\r\n        }\r\n        else if (nombreAleatoire == 1 && !somethingRIGHT && ghost.getPreviousDirection() != MoveDirection.LEFT){\r\n            ghost.getKeepDirection().put(\"KeepRight\",true);\r\n            ghost.setPreviousDirection(MoveDirection.RIGHT);\r\n            return MoveDirection.RIGHT;\r\n        }\r\n        else if (nombreAleatoire == 1 && !somethingLEFT && ghost.getPreviousDirection() != MoveDirection.RIGHT){\r\n            ghost.getKeepDirection().put(\"KeepLeft\",true);\r\n            ghost.setPreviousDirection(MoveDirection.LEFT);\r\n            return MoveDirection.LEFT;\r\n        }\r\n        else if (nombreAleatoire == 1){\r\n            ghost.getKeepDirection().put(\"KeepDown\",true);\r\n            ghost.setPreviousDirection(MoveDirection.DOWN);\r\n            return MoveDirection.DOWN;\r\n        }\r\n\r\n        if (nombreAleatoire == 2 && !somethingRIGHT  && ghost.getPreviousDirection() != MoveDirection.LEFT){\r\n            ghost.getKeepDirection().put(\"KeepRight\",true);\r\n            ghost.setPreviousDirection(MoveDirection.RIGHT);\r\n            return MoveDirection.RIGHT;\r\n        }\r\n        else if (nombreAleatoire == 2 && !somethingDOWN && ghost.getPreviousDirection() != MoveDirection.UP){\r\n            ghost.getKeepDirection().put(\"KeepDown\",true);\r\n            ghost.setPreviousDirection(MoveDirection.UP);\r\n            return MoveDirection.DOWN;\r\n        }\r\n        else if (nombreAleatoire == 2 && !somethingUP && ghost.getPreviousDirection() != MoveDirection.DOWN){\r\n            ghost.getKeepDirection().put(\"KeepUp\",true);\r\n            ghost.setPreviousDirection(MoveDirection.UP);\r\n            return MoveDirection.UP;\r\n        }\r\n        else if (nombreAleatoire == 2) {\r\n            ghost.getKeepDirection().put(\"KeepLeft\",true);\r\n            ghost.setPreviousDirection(MoveDirection.LEFT);\r\n            return MoveDirection.LEFT;\r\n        }\r\n\r\n        if (nombreAleatoire == 3 && !somethingDOWN && ghost.getPreviousDirection() != MoveDirection.UP){\r\n            ghost.getKeepDirection().put(\"KeepDown\",true);\r\n            ghost.setPreviousDirection(MoveDirection.UP);\r\n            return MoveDirection.DOWN;\r\n        }\r\n        else if (nombreAleatoire == 3 && !somethingLEFT && ghost.getPreviousDirection() != MoveDirection.RIGHT){\r\n            ghost.getKeepDirection().put(\"KeepLeft\",true);\r\n            ghost.setPreviousDirection(MoveDirection.LEFT);\r\n            return MoveDirection.LEFT;\r\n        }\r\n        else if (nombreAleatoire == 3 && !somethingRIGHT  && ghost.getPreviousDirection() != MoveDirection.LEFT){\r\n            ghost.getKeepDirection().put(\"KeepRight\",true);\r\n            ghost.setPreviousDirection(MoveDirection.RIGHT);\r\n            return MoveDirection.RIGHT;\r\n        }\r\n        else if (nombreAleatoire == 3){\r\n            ghost.getKeepDirection().put(\"KeepUp\",true);\r\n            ghost.setPreviousDirection(MoveDirection.UP);\r\n            return MoveDirection.UP;\r\n        }\r\n\r\n        if (nombreAleatoire == 4 && !somethingLEFT && ghost.getPreviousDirection() != MoveDirection.RIGHT){\r\n            ghost.getKeepDirection().put(\"KeepLeft\",true);\r\n            ghost.setPreviousDirection(MoveDirection.LEFT);\r\n            return MoveDirection.LEFT;\r\n        }\r\n        else if (nombreAleatoire == 4 && !somethingDOWN && ghost.getPreviousDirection() != MoveDirection.UP){\r\n            ghost.getKeepDirection().put(\"KeepDown\",true);\r\n            ghost.setPreviousDirection(MoveDirection.UP);\r\n            return MoveDirection.DOWN;\r\n        }\r\n        else if (nombreAleatoire == 4 && !somethingUP  && ghost.getPreviousDirection() != MoveDirection.DOWN){\r\n            ghost.getKeepDirection().put(\"KeepUp\",true);\r\n            ghost.setPreviousDirection(MoveDirection.UP);\r\n            return MoveDirection.UP;\r\n        }\r\n        else if (nombreAleatoire == 4){\r\n            ghost.getKeepDirection().put(\"KeepRight\",true);\r\n            ghost.setPreviousDirection(MoveDirection.RIGHT);\r\n            return MoveDirection.RIGHT;\r\n        }\r\n\r\n        ghost.setPreviousDirection(MoveDirection.RIGHT);\r\n        return MoveDirection.RIGHT; //default move\r\n        //random direction\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * Changer la direction de pacman\r\n     * @param direction direction\r\n     */\r\n    private void switchPacmanDirection(MoveDirection direction) {\r\n        pacman.setCurrentAnimationID(pacman.getAnimations().get(direction.name()));\r\n        if (!graphicsEngine().getAnimation(pacman.getCurrentAnimationID()).isPlaying())\r\n            graphicsEngine().playPauseAnimation(pacman.getCurrentAnimationID());\r\n        setEntityNextDirection(pacman,direction);\r\n    }\r\n\r\n    /**\r\n     * Vérifier les collisions de Pacman\r\n     */\r\n    private void checkPacmanCollisions() {\r\n\r\n        ArrayList<PhysicEntity> collidingEntities = new ArrayList<>();\r\n        collidingEntities.add(physicsEngine().isSomethingUp(pacman));\r\n        collidingEntities.add(physicsEngine().isSomethingRight(pacman));\r\n        collidingEntities.add(physicsEngine().isSomethingDown(pacman));\r\n        collidingEntities.add(physicsEngine().isSomethingLeft(pacman));\r\n\r\n        if (pacman.getCurrentAnimationID() != 0)\r\n            if (graphicsEngine().getAnimation(pacman.getCurrentAnimationID()).isPlaying())\r\n                graphicsEngine().playPauseAnimation(pacman.getCurrentAnimationID());\r\n\r\n        for (Ghost ghost : ghosts.values()) {\r\n            if (collidingEntities.contains(ghost.getPhysicEntity())) {\r\n\r\n                // Si les fantômes sont appeurés\r\n                if (ghostFear) {\r\n                    this.currentLevel.updateActualScore(this.currentLevel.getActualScore() + 250);\r\n                    physicsEngine().removeCollisions(pacman.getPhysicEntity(), ghost.getPhysicEntity());\r\n                    ghost.setEaten(true);\r\n                    updateEatenGhostSkin();\r\n\r\n                    new Thread( () -> {\r\n                        long startTime = System.currentTimeMillis();\r\n                        while(((System.currentTimeMillis() - startTime)/1000) < 7) {;}\r\n                        physicsEngine().addCollisions(pacman, ghost);\r\n                        ghost.setEaten(false);\r\n                        updateEatenGhostSkin();\r\n                    }).start();\r\n                }\r\n\r\n                else {\r\n                    currentLevel.updateLives();\r\n                    soundEngine().playSound(pacman.getDeath1Sound());\r\n                    soundEngine().getSounds().get(pacman.getDeath1Sound()).addLineListener(e -> {\r\n                        if (e.getType() == LineEvent.Type.STOP) {\r\n                            soundEngine().playSound(pacman.getDeath2Sound());\r\n                        }\r\n                    });\r\n\r\n                    kernelEngine.pauseEvents();\r\n                    graphicsEngine().bindAnimation(pacman, pacman.getAnimations().get(\"DEATH\"));\r\n                    new Thread(() -> {\r\n                        try {\r\n                            sleep(2000);\r\n                        } catch (InterruptedException e) {\r\n                            e.printStackTrace();\r\n                        }\r\n                        kernelEngine.resumeEvents();\r\n                        if (currentLevel.getLivesCount() > 0) {\r\n                            playLevel(currentLevel);\r\n                        } else {\r\n                            showEndGameView();\r\n                        }\r\n                    }).start();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Incrémente le volume 5 par 5\r\n     */\r\n    private void incrementGlobalVolume(){\r\n        soundEngine().incrementGlobalVolume();\r\n        graphicsEngine().bindText(currentVolume, \"Volume is : \" + (int)(soundEngine().getGlobalvolume()*100), new Color(255,255,255), 20, true);\r\n    }\r\n\r\n    /**\r\n     * Décrémente le son 5 par 5\r\n     * le son étant un logarithme la décrémentation ne se fait pas très bien et\r\n     * nous nous retrouvons avec des nombre du style 24 de volume  mais cela n'est pas important\r\n     */\r\n    private void decrementGlobalVolume(){\r\n        soundEngine().decrementGlobalVolume();\r\n        graphicsEngine().bindText(currentVolume, \"Volume is : \" + (int)(soundEngine().getGlobalvolume()*100), new Color(255,255,255), 20, true);\r\n    }\r\n\r\n    /**\r\n     * Déterminer la prochaine direction de l'entité\r\n     * @param entity entité\r\n     * @param direction direction\r\n     */\r\n    private void setEntityNextDirection(Player entity, MoveDirection direction) {\r\n        PhysicEntity entityNearby;\r\n        switch (direction) {\r\n            case UP:\r\n                entityNearby = physicsEngine().isSomethingUp(entity);\r\n                if (entityNearby == null)\r\n                    entity.setCurrentDirection(MoveDirection.UP);\r\n                break;\r\n            case RIGHT:\r\n                entityNearby = physicsEngine().isSomethingRight(entity);\r\n                if (entityNearby == null)\r\n                    entity.setCurrentDirection(MoveDirection.RIGHT);\r\n                break;\r\n            case DOWN:\r\n                entityNearby = physicsEngine().isSomethingDown(entity);\r\n                if (entityNearby == null)\r\n                    entity.setCurrentDirection(MoveDirection.DOWN);\r\n                break;\r\n            case LEFT:\r\n                entityNearby = physicsEngine().isSomethingLeft(entity);\r\n                if (entityNearby == null)\r\n                    entity.setCurrentDirection(MoveDirection.LEFT);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        if (entity.getCurrentDirection() != null) {\r\n            callEventFromDirection(entity, entity.getCurrentDirection());\r\n            graphicsEngine().bindAnimation(entity, entity.getAnimations().get(entity.getCurrentDirection().name()));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Appeler la méthode de déplacement en fonction de la direction courante\r\n     */\r\n    private void callEventFromDirection(Entity entity, MoveDirection direction) {\r\n        if (direction != null) {\r\n            switch (direction) {\r\n                case UP:\r\n                    physicsEngine().goUp(entity);\r\n                    break;\r\n                case RIGHT:\r\n                    physicsEngine().goRight(entity);\r\n                    break;\r\n                case DOWN:\r\n                    physicsEngine().goDown(entity);\r\n                    break;\r\n                case LEFT:\r\n                    physicsEngine().goLeft(entity);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Générer un niveau\r\n     * @param rows nombre de lignes\r\n     * @param cols nombre de colonnes\r\n     */\r\n    protected Level generateLevel(int rows, int cols) {\r\n        Level level = new Level(this,rows,cols);\r\n        levels.add(level);\r\n        return level;\r\n    }\r\n\r\n    /**\r\n     * Faire apparaitre les joueurs sur le niveau actuel\r\n     */\r\n    protected void spawnPlayersOnLevel() {\r\n        currentLevel.spawnPlayer(15,9);\r\n        currentLevel.spawnGhost(ghosts.get(\"red\"),11,9);\r\n        currentLevel.spawnGhost(ghosts.get(\"blue\"),11,8);\r\n        currentLevel.spawnGhost(ghosts.get(\"pink\"),9,9);\r\n        currentLevel.spawnGhost(ghosts.get(\"orange\"),9,10);\r\n    }\r\n\r\n    /**\r\n     * Jouer un niveau\r\n     * @param level level\r\n     */\r\n    protected void playLevel(Level level) {\r\n        ioEngine().resetLastPressedKey();\r\n        currentLevel = level;\r\n        if (currentLevel.getLivesCount() == 3) {\r\n            soundEngine().playSound(\"gameStart\");\r\n            kernelEngine.pauseEvents();\r\n            new Thread(() -> {\r\n                try {\r\n                    sleep(4000);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                kernelEngine.resumeEvents();\r\n            }).start();\r\n        }\r\n        spawnPlayersOnLevel();\r\n        graphicsEngine().bindScene(currentLevel.getScene());\r\n    }\r\n\r\n    /**\r\n     * Mettre à jour les textures des fantômes selon s'ils\r\n     * sont appeurés ou non\r\n     */\r\n    public void updateFearGhostSkin() {\r\n        if (ghostFear) {\r\n            for (Ghost ghost : ghosts.values()) {\r\n                if (!ghost.getEaten()) {\r\n                    graphicsEngine().bindTexture(ghost, textures, 8, 1);\r\n\r\n                    int moveUP = ghost.getAnimations().get(MoveDirection.UP.name());\r\n                    graphicsEngine().clearFrameOfAnimation(moveUP);\r\n                    graphicsEngine().addFrameToAnimation(moveUP, 8, 1);\r\n                    graphicsEngine().addFrameToAnimation(moveUP, 8, 2);\r\n\r\n                    int moveDOWN = ghost.getAnimations().get(MoveDirection.DOWN.name());\r\n                    graphicsEngine().clearFrameOfAnimation(moveDOWN);\r\n                    graphicsEngine().addFrameToAnimation(moveDOWN, 8, 1);\r\n                    graphicsEngine().addFrameToAnimation(moveDOWN, 8, 2);\r\n\r\n                    int moveLEFT = ghost.getAnimations().get(MoveDirection.LEFT.name());\r\n                    graphicsEngine().clearFrameOfAnimation(moveLEFT);\r\n                    graphicsEngine().addFrameToAnimation(moveLEFT, 8, 1);\r\n                    graphicsEngine().addFrameToAnimation(moveLEFT, 8, 2);\r\n\r\n                    int moveRIGHT = ghost.getAnimations().get(MoveDirection.RIGHT.name());\r\n                    graphicsEngine().clearFrameOfAnimation(moveRIGHT);\r\n                    graphicsEngine().addFrameToAnimation(moveRIGHT, 8, 1);\r\n                    graphicsEngine().addFrameToAnimation(moveRIGHT, 8, 2);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (Ghost ghost : ghosts.values()) {\r\n                if (!ghost.getEaten()) {\r\n                    graphicsEngine().bindTexture(ghost, textures, ghost.defaultTextureCoords[0], ghost.defaultTextureCoords[1]);\r\n                    int moveUP = ghost.getAnimations().get(MoveDirection.UP.name());\r\n                    graphicsEngine().clearFrameOfAnimation(moveUP);\r\n                    int moveDOWN = ghost.getAnimations().get(MoveDirection.DOWN.name());\r\n                    graphicsEngine().clearFrameOfAnimation(moveDOWN);\r\n                    int moveLEFT = ghost.getAnimations().get(MoveDirection.LEFT.name());\r\n                    graphicsEngine().clearFrameOfAnimation(moveLEFT);\r\n                    int moveRIGHT = ghost.getAnimations().get(MoveDirection.RIGHT.name());\r\n                    graphicsEngine().clearFrameOfAnimation(moveRIGHT);\r\n                    ghost.initAnimations(textures);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Mettre à jour le skin d'un fantome mangé\r\n     */\r\n    public void updateEatenGhostSkin() {\r\n        for (Ghost ghost: ghosts.values()) {\r\n            if (ghost.getEaten()) {\r\n                graphicsEngine().bindTexture(ghost, textures, 7, 1);\r\n\r\n                int moveUP = ghost.getAnimations().get(MoveDirection.UP.name());\r\n                graphicsEngine().clearFrameOfAnimation(moveUP);\r\n                graphicsEngine().addFrameToAnimation(moveUP, 7, 1);\r\n                graphicsEngine().addFrameToAnimation(moveUP, 7, 2);\r\n\r\n                int moveDOWN = ghost.getAnimations().get(MoveDirection.DOWN.name());\r\n                graphicsEngine().clearFrameOfAnimation(moveDOWN);\r\n                graphicsEngine().addFrameToAnimation(moveDOWN, 7, 1);\r\n                graphicsEngine().addFrameToAnimation(moveDOWN, 7, 2);\r\n\r\n                int moveLEFT = ghost.getAnimations().get(MoveDirection.LEFT.name());\r\n                graphicsEngine().clearFrameOfAnimation(moveLEFT);\r\n                graphicsEngine().addFrameToAnimation(moveLEFT, 7, 1);\r\n                graphicsEngine().addFrameToAnimation(moveLEFT, 7, 2);\r\n\r\n                int moveRIGHT = ghost.getAnimations().get(MoveDirection.RIGHT.name());\r\n                graphicsEngine().clearFrameOfAnimation(moveRIGHT);\r\n                graphicsEngine().addFrameToAnimation(moveRIGHT, 7, 1);\r\n                graphicsEngine().addFrameToAnimation(moveRIGHT, 7, 2);\r\n            }\r\n            else {\r\n                if (!ghostFear) {\r\n                    graphicsEngine().bindTexture(ghost, textures, ghost.defaultTextureCoords[0], ghost.defaultTextureCoords[1]);\r\n                    int moveUP = ghost.getAnimations().get(MoveDirection.UP.name());\r\n                    graphicsEngine().clearFrameOfAnimation(moveUP);\r\n                    int moveDOWN = ghost.getAnimations().get(MoveDirection.DOWN.name());\r\n                    graphicsEngine().clearFrameOfAnimation(moveDOWN);\r\n                    int moveLEFT = ghost.getAnimations().get(MoveDirection.LEFT.name());\r\n                    graphicsEngine().clearFrameOfAnimation(moveLEFT);\r\n                    int moveRIGHT = ghost.getAnimations().get(MoveDirection.RIGHT.name());\r\n                    graphicsEngine().clearFrameOfAnimation(moveRIGHT);\r\n                    ghost.initAnimations(textures);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Afficher la vue de fin de jeu\r\n     */\r\n    protected void showEndGameView() {\r\n        GraphicEntity score = endGameView.getEntities().get(1);\r\n        graphicsEngine().bindText(score.getParent(), \"Score : \" + currentLevel.getActualScore(),\r\n                new Color(255,255,255), 20, true);\r\n        graphicsEngine().bindScene(endGameView);\r\n    }\r\n\r\n    /**\r\n     * Lancer le jeu\r\n     */\r\n    public void start() {\r\n        graphicsEngine().bindScene(menuView);\r\n        kernelEngine.start();\r\n    }\r\n\r\n    // GETTERS //\r\n\r\n    public int getTexturesFile() { return textures; }\r\n\r\n    public KernelEngine kernelEngine() { return kernelEngine; }\r\n\r\n    public GraphicsEngine graphicsEngine() { return kernelEngine.getGraphicsEngine(); }\r\n\r\n    public IOEngine ioEngine() { return kernelEngine.getIoEngine(); }\r\n\r\n    public PhysicsEngine physicsEngine() { return kernelEngine.getPhysicsEngine(); }\r\n\r\n    public SoundEngine soundEngine() { return kernelEngine.getSoundEngine(); }\r\n\r\n    public AIEngine aiEngine() { return kernelEngine.getAiEngine(); }\r\n\r\n    public Pacman getPlayer() { return pacman; }\r\n\r\n    public Map<String,Ghost> getGhosts() { return ghosts; }\r\n\r\n    public ArrayList<Level> getLevels() { return levels; }\r\n\r\n    // SETTERS //\r\n\r\n    /**\r\n     * Mettre à jour la peur des fantômes\r\n     * et appel au changement de textures\r\n     *\r\n     * Mise en place d'un timer, à la fin de celui-ci les fantômes redeviennent normaux\r\n     * @param fear\r\n     */\r\n    public void setGhostFear(boolean fear) {\r\n        this.ghostFear = fear;\r\n        updateFearGhostSkin();\r\n\r\n        new Thread( () -> {\r\n            long startTime = System.currentTimeMillis();\r\n            while(((System.currentTimeMillis() - startTime)/1000) < 5) {;}\r\n\r\n            this.ghostFear = false;\r\n            updateFearGhostSkin();\r\n        }).start();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/gameplay/Gameplay.java b/src/main/java/gameplay/Gameplay.java
--- a/src/main/java/gameplay/Gameplay.java	(revision 26e55a96c14d97b8656d165ad2fc8ac3b2811e59)
+++ b/src/main/java/gameplay/Gameplay.java	(date 1606925535419)
@@ -543,16 +543,8 @@
                 int targetX = (targetBottomRight.getX());
                 int targetY = (targetBottomRight.getY());
 
-                /*System.out.println(targetX+4);
-                System.out.println(targetX-4);
-                System.out.println(ghostX);
-                System.out.println(targetY+4);
-                System.out.println(targetY-4);
-                System.out.println(ghostY);*/
                 if ((ghostX <= (targetX+4)) && (ghostX >= (targetX-4)) && (ghostY <= (targetY+4)) && (ghostY >= (targetY-4))){
-                    System.out.println("pass");
                     ghost.setPatroleZoneReached(true);
-                    System.out.println(ghost.isPatroleZoneReached());
                 }
                 return;
             }
@@ -585,7 +577,6 @@
 
         int nombreAleatoire = 1 + (int)(Math.random() * ((4 - 1) + 1));
         HashMap<String,Boolean> keepDirection = ghost.getKeepDirection() ;
-        System.out.println(nombreAleatoire);
 
         if (keepDirection.get("KeepUp") && somethingLEFT && somethingRIGHT && !somethingUP){
             ghost.setPreviousDirection(MoveDirection.UP);
