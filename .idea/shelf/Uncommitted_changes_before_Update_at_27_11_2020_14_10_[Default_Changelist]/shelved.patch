Index: src/main/java/gameplay/Ghost.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package gameplay;\r\n\r\n/**\r\n * Fantome\r\n */\r\npublic class Ghost extends Player {\r\n    /**\r\n     * Gameplay\r\n     */\r\n    private Gameplay gameplay;\r\n\r\n    /**\r\n     * Constructeur\r\n     * @param gameplay gameplay\r\n     */\r\n    public Ghost(Gameplay gameplay) {\r\n        super(gameplay.kernelEngine());\r\n        this.gameplay = gameplay;\r\n        this.defaultTextureCoords = new int[]{3, 1};\r\n        gameplay.physicsEngine().resize(getPhysicEntity(), 30, 30);\r\n        gameplay.physicsEngine().setSpeed(getPhysicEntity(), 1);\r\n        initAnimations(gameplay.getTexturesFile());\r\n    }\r\n\r\n    /**\r\n     * Initialiser les animation\r\n     * @param spriteSheetID identifiant du fichier de textures\r\n     */\r\n    private void initAnimations(int spriteSheetID) {\r\n        int animationsSpeed = 4;\r\n\r\n        int moveUP = gameplay.graphicsEngine().generateAnimation(spriteSheetID, animationsSpeed, true);\r\n        gameplay.graphicsEngine().addFrameToAnimation(moveUP,3,7);\r\n        gameplay.graphicsEngine().addFrameToAnimation(moveUP,3,8);\r\n        animations.put(Gameplay.MoveDirection.UP.name(), moveUP);\r\n\r\n        int moveRIGHT = gameplay.graphicsEngine().generateAnimation(spriteSheetID, animationsSpeed, true);\r\n        gameplay.graphicsEngine().addFrameToAnimation(moveRIGHT,3,1);\r\n        gameplay.graphicsEngine().addFrameToAnimation(moveRIGHT,3,2);\r\n        animations.put(Gameplay.MoveDirection.RIGHT.name(), moveRIGHT);\r\n\r\n        int moveDOWN = gameplay.graphicsEngine().generateAnimation(spriteSheetID, animationsSpeed, true);\r\n        gameplay.graphicsEngine().addFrameToAnimation(moveDOWN,3,3);\r\n        gameplay.graphicsEngine().addFrameToAnimation(moveDOWN,3,4);\r\n        animations.put(Gameplay.MoveDirection.DOWN.name(), moveDOWN);\r\n\r\n        int moveLEFT = gameplay.graphicsEngine().generateAnimation(spriteSheetID, animationsSpeed, true);\r\n        gameplay.graphicsEngine().addFrameToAnimation(moveLEFT,3,5);\r\n        gameplay.graphicsEngine().addFrameToAnimation(moveLEFT,3,6);\r\n        animations.put(Gameplay.MoveDirection.LEFT.name(), moveLEFT);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/gameplay/Ghost.java	(revision a2b889051a437f0dabc13e22187e52207ff63aa3)
+++ src/main/java/gameplay/Ghost.java	(date 1606482336764)
@@ -13,6 +13,11 @@
      * Constructeur
      * @param gameplay gameplay
      */
+    private boolean keepUp = false;
+    private boolean keepDown= false;
+    private boolean keepLeft= false;
+    private boolean keepRight= false;
+
     public Ghost(Gameplay gameplay) {
         super(gameplay.kernelEngine());
         this.gameplay = gameplay;
@@ -49,4 +54,24 @@
         gameplay.graphicsEngine().addFrameToAnimation(moveLEFT,3,6);
         animations.put(Gameplay.MoveDirection.LEFT.name(), moveLEFT);
     }
+
+    public boolean isKeepDown() {
+        return keepDown;
+    }
+
+    public boolean isKeepLeft() {
+        return keepLeft;
+    }
+
+    public boolean isKeepRight() {
+        return keepRight;
+    }
+
+    public boolean isKeepUp() {
+        return keepUp;
+    }
+
+    public void setKeepUp(boolean keep){
+        keepUp = keep;
+    }
 }
Index: src/main/java/gameplay/Gameplay.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package gameplay;\r\n\r\nimport engines.AI.AIEngine;\r\nimport engines.graphics.GraphicsEngine;\r\nimport engines.graphics.Scene;\r\nimport engines.input_output.IOEngine;\r\nimport engines.kernel.Entity;\r\nimport engines.kernel.KernelEngine;\r\nimport engines.physics.PhysicEntity;\r\nimport engines.physics.PhysicsEngine;\r\nimport engines.sound.SoundEngine;\r\n\r\nimport java.awt.event.KeyEvent;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * Gameplay\r\n */\r\npublic class Gameplay {\r\n    /**\r\n     * Directions de déplacement\r\n     */\r\n    public enum MoveDirection {\r\n        UP,RIGHT,DOWN,LEFT\r\n    }\r\n\r\n    /**\r\n     * Moteur noyau\r\n     */\r\n    private final KernelEngine kernelEngine;\r\n\r\n    /**\r\n     * Identifiant du fichier contenant les textures du jeu\r\n     */\r\n    private final int textures;\r\n\r\n    /**\r\n     * Identifiant scène\r\n     */\r\n    private Scene menuView;\r\n\r\n    /**\r\n     * Niveaux disponibles\r\n     */\r\n    private ArrayList<Level> levels;\r\n\r\n    /**\r\n     * Joueur\r\n     */\r\n    private final Pacman pacman;\r\n\r\n    private final ArrayList<Ghost> ghosts;\r\n\r\n    /**\r\n     * Constructeur\r\n     */\r\n    public Gameplay() {\r\n        this.kernelEngine = new KernelEngine();\r\n        this.textures = kernelEngine.getGraphicsEngine().loadSpriteSheet(\"assets/sprite_sheet.png\", 11, 11);\r\n        this.levels = new ArrayList<>();\r\n        this.pacman = new Pacman(this);\r\n        this.ghosts = new ArrayList<>();\r\n        ghosts.add(new Ghost(this));\r\n        initGameplay();\r\n    }\r\n\r\n    /**\r\n     * Initialiser le gameplay\r\n     */\r\n    private void initGameplay() {\r\n        //Activation des entrées / sorties clavier\r\n        ioEngine().enableKeyboardIO();\r\n        initEvents();\r\n        initSounds();\r\n        initMenu();\r\n    }\r\n\r\n    /**\r\n     * Initialiser les évènements du jeu\r\n     */\r\n    private void initEvents() {\r\n        kernelEngine.addEvent(\"moveGhost\", () -> {\r\n            for (Ghost ghost : ghosts)\r\n                updateGhostDirection(ghost);\r\n        });\r\n        //Se déplacer vers le haut\r\n        kernelEngine.addEvent(\"pacmanGoUp\", () -> switchPacmanDirection(MoveDirection.UP));\r\n        //Se déplacer vers la droite\r\n        kernelEngine.addEvent(\"pacmanGoRight\", () -> switchPacmanDirection(MoveDirection.RIGHT));\r\n        //Se déplacer vers le bas\r\n        kernelEngine.addEvent(\"pacmanGoDown\", () -> switchPacmanDirection(MoveDirection.DOWN));\r\n        //Se déplacer vers la gauche\r\n        kernelEngine.addEvent(\"pacmanGoLeft\", () -> switchPacmanDirection(MoveDirection.LEFT));\r\n        //Attacher la texture par défaut au joueur\r\n        kernelEngine.addEvent(\"pacmanBindDefaultTexture\", () ->\r\n                graphicsEngine().bindTexture(pacman.getGraphicEntity(),\r\n                        textures, pacman.getDefaultTextureCoords()[0], pacman.getDefaultTextureCoords()[1]));\r\n        //Lorsqu'il y a une collision\r\n        kernelEngine.addEvent(\"pacmanOnCollision\", () -> {\r\n            if (pacman.getCurrentAnimationID() != 0)\r\n                if (graphicsEngine().getAnimation(pacman.getCurrentAnimationID()).isPlaying())\r\n                    graphicsEngine().playPauseAnimation(pacman.getCurrentAnimationID());\r\n        });\r\n        //Rejouer l'animation courante\r\n        kernelEngine.addEvent(\"pacmanPlayCurrentAnimation\", () -> {\r\n            if (!graphicsEngine().getAnimation(pacman.getCurrentAnimationID()).isPlaying())\r\n                graphicsEngine().playPauseAnimation(pacman.getCurrentAnimationID());\r\n        });\r\n        ioEngine().bindEventOnLastKey(KeyEvent.VK_UP, \"pacmanGoUp\");\r\n        ioEngine().bindEventOnLastKey(KeyEvent.VK_RIGHT, \"pacmanGoRight\");\r\n        ioEngine().bindEventOnLastKey(KeyEvent.VK_DOWN, \"pacmanGoDown\");\r\n        ioEngine().bindEventOnLastKey(KeyEvent.VK_LEFT, \"pacmanGoLeft\");\r\n        ioEngine().bindEventKeyboardFree(\"pacmanBindDefaultTexture\");\r\n        physicsEngine().bindEventOnCollision(pacman.getPhysicEntity(), \"pacmanOnCollision\");\r\n        for (Ghost ghost : ghosts)\r\n            aiEngine().bindEvent(ghost.getAiEntity(), \"moveGhost\");\r\n    }\r\n\r\n    /**\r\n     * Initialiser les sons du jeu\r\n     */\r\n    private void initSounds() {\r\n        soundEngine().loadSound(\"munch.wav\",\"munch\");\r\n    }\r\n\r\n    /**\r\n     * Initialiser le menu\r\n     */\r\n    private void initMenu() {\r\n        this.menuView = graphicsEngine().generateScene(400,400);\r\n    }\r\n\r\n    /**\r\n     * Mettre à jour la position d'un fanôme\r\n     * @param ghost fantôme\r\n     */\r\n    protected void updateGhostDirection(Ghost ghost) {\r\n        PhysicEntity playerPhysic = pacman.getPhysicEntity();\r\n        PhysicEntity ghostPhysic = ghost.getPhysicEntity();\r\n\r\n\r\n        int playerXmiddle = (playerPhysic.getX() + playerPhysic.getWidth())/2;\r\n        int playerYmiddle = (playerPhysic.getY() + playerPhysic.getHeight())/2;\r\n        int ghostXmiddle = (ghostPhysic.getX() + ghostPhysic.getWidth())/2;\r\n        int ghostYmiddle = (ghostPhysic.getY() + ghostPhysic.getHeight())/2;\r\n        int xDistance = playerXmiddle - ghostXmiddle;\r\n        int yDistance = playerYmiddle - ghostYmiddle;\r\n\r\n        MoveDirection direction;\r\n        PhysicEntity entityOnTheWay;\r\n\r\n        if (Math.abs(xDistance) > Math.abs(yDistance)) {\r\n            if (xDistance < 0) {\r\n                entityOnTheWay = physicsEngine().isSomethingLeftInLine(ghostPhysic,Math.abs(xDistance));\r\n                if (entityOnTheWay != null){\r\n                    int entityOnTheWayXMiddle = (entityOnTheWay.getX() + entityOnTheWay.getWidth())/2;\r\n                    int xDistanceWithWall =  entityOnTheWayXMiddle - ghostXmiddle;\r\n                    if ((Math.abs(xDistance) > Math.abs(xDistanceWithWall)) && (Math.abs(xDistanceWithWall) <= (ghostPhysic.getWidth()/2 + entityOnTheWay.getWidth()/2)/2)){ //si la distance entre fantome et pacman est inférieure a la distance entre fantome et mur\r\n                        if (yDistance < 0) direction = MoveDirection.UP;\r\n                        else direction = MoveDirection.DOWN;\r\n                    }\r\n                    else {\r\n                        direction = MoveDirection.LEFT;\r\n                    }\r\n                }\r\n                else {\r\n                    direction = MoveDirection.LEFT;\r\n                }\r\n            }\r\n            else {\r\n                entityOnTheWay = physicsEngine().isSomethingRightInLine(ghostPhysic,Math.abs(xDistance));\r\n                if (entityOnTheWay != null){\r\n                    int entityOnTheWayXMiddle = (entityOnTheWay.getX() + entityOnTheWay.getWidth())/2;\r\n                    int xDistanceWithWall =  entityOnTheWayXMiddle - ghostXmiddle;\r\n                    if ((Math.abs(xDistance) > Math.abs(xDistanceWithWall)) && (Math.abs(xDistanceWithWall) <= (ghostPhysic.getWidth()/2 + entityOnTheWay.getWidth()/2)/2)){ //si la distance entre fantome et pacman est inférieure a la distance entre fantome et mur\r\n                        if (yDistance < 0) direction = MoveDirection.UP;\r\n                        else direction = MoveDirection.DOWN;\r\n                    }\r\n                    else {\r\n                        direction = MoveDirection.RIGHT;\r\n                    }\r\n                }\r\n                else {\r\n                    direction = MoveDirection.RIGHT;\r\n                }\r\n            }\r\n        } else {\r\n            if (yDistance < 0) {\r\n                entityOnTheWay = physicsEngine().isSomethingUpInLine(ghostPhysic,Math.abs(yDistance));\r\n                if (entityOnTheWay != null){\r\n                    int entityOnTheWayYMiddle = (entityOnTheWay.getY() + entityOnTheWay.getHeight())/2;\r\n                    int yDistanceWithWall =  entityOnTheWayYMiddle - ghostYmiddle;\r\n                    if ((Math.abs(yDistance) > Math.abs(yDistanceWithWall)) && (Math.abs(yDistanceWithWall) <= (ghostPhysic.getHeight()/2 + entityOnTheWay.getHeight()/2)/2)){ //si la distance entre fantome et pacman est inférieure a la distance entre fantome et mur\r\n                        if (xDistance < 0) direction = MoveDirection.LEFT;\r\n                        else direction = MoveDirection.RIGHT;\r\n                    }\r\n                    else {\r\n                        direction = MoveDirection.UP;\r\n                    }\r\n                }\r\n                else {\r\n                    direction = MoveDirection.UP;\r\n                }\r\n            }\r\n            else {\r\n                entityOnTheWay = physicsEngine().isSomethingDownInLine(ghostPhysic,Math.abs(yDistance));\r\n                if (entityOnTheWay != null){\r\n                    int entityOnTheWayYMiddle = (entityOnTheWay.getY() + entityOnTheWay.getHeight())/2;\r\n                    int yDistanceWithWall =  entityOnTheWayYMiddle - ghostYmiddle;\r\n                    if ((Math.abs(yDistance) > Math.abs(yDistanceWithWall)) && (Math.abs(yDistanceWithWall) <= (ghostPhysic.getHeight()/2 + entityOnTheWay.getHeight()/2)/2)){ //si la distance entre fantome et pacman est inférieure a la distance entre fantome et mur\r\n                        if (xDistance < 0) direction = MoveDirection.LEFT;\r\n                        else direction = MoveDirection.RIGHT;\r\n                    }\r\n                    else {\r\n                        direction = MoveDirection.DOWN;\r\n                    }\r\n                }\r\n                else {\r\n                    direction = MoveDirection.DOWN;\r\n                }\r\n            }\r\n        }\r\n        setEntityNextDirection(ghost,direction);\r\n    }\r\n\r\n    /**\r\n     * Changer la direction de pacman\r\n     * @param direction direction\r\n     */\r\n    protected void switchPacmanDirection(MoveDirection direction) {\r\n        pacman.setCurrentAnimationID(pacman.getAnimations().get(direction.name()));\r\n        kernelEngine().notifyEvent(\"pacmanPlayCurrentAnimation\");\r\n        setEntityNextDirection(pacman,direction);\r\n    }\r\n\r\n    /**\r\n     * Déterminer la prochaine direction de l'entité\r\n     * @param entity entité\r\n     * @param direction direction\r\n     */\r\n    private void setEntityNextDirection(Player entity, MoveDirection direction) {\r\n        PhysicEntity entityNearby;\r\n        switch (direction) {\r\n            case UP:\r\n                entityNearby = physicsEngine().isSomethingUp(entity.getPhysicEntity());\r\n                if (entityNearby == null)\r\n                    entity.setCurrentDirection(MoveDirection.UP);\r\n                break;\r\n            case RIGHT:\r\n                entityNearby = physicsEngine().isSomethingRight(entity.getPhysicEntity());\r\n                if (entityNearby == null)\r\n                    entity.setCurrentDirection(MoveDirection.RIGHT);\r\n                break;\r\n            case DOWN:\r\n                entityNearby = physicsEngine().isSomethingDown(entity.getPhysicEntity());\r\n                if (entityNearby == null)\r\n                    entity.setCurrentDirection(MoveDirection.DOWN);\r\n                break;\r\n            case LEFT:\r\n                entityNearby = physicsEngine().isSomethingLeft(entity.getPhysicEntity());\r\n                if (entityNearby == null)\r\n                    entity.setCurrentDirection(MoveDirection.LEFT);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        callEventFromDirection(entity, entity.getCurrentDirection());\r\n        graphicsEngine().bindAnimation(entity.getGraphicEntity(), entity.getAnimations().get(entity.getCurrentDirection().name()));\r\n    }\r\n\r\n    /**\r\n     * Appeler la méthode de déplacement en fonction de la direction courante\r\n     */\r\n    private void callEventFromDirection(Entity entity, MoveDirection direction) {\r\n        if (direction != null) {\r\n            switch (direction) {\r\n                case UP:\r\n                    physicsEngine().goUp(entity.getPhysicEntity());\r\n                    break;\r\n                case RIGHT:\r\n                    physicsEngine().goRight(entity.getPhysicEntity());\r\n                    break;\r\n                case DOWN:\r\n                    physicsEngine().goDown(entity.getPhysicEntity());\r\n                    break;\r\n                case LEFT:\r\n                    physicsEngine().goLeft(entity.getPhysicEntity());\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Générer un niveau\r\n     * @param rows nombre de lignes\r\n     * @param cols nombre de colonnes\r\n     */\r\n    public Level generateLevel(int rows, int cols) {\r\n        Level level = new Level(this,rows,cols);\r\n        this.levels.add(level);\r\n        return level;\r\n    }\r\n\r\n    /**\r\n     * Jouer un niveau\r\n     * @param level level\r\n     */\r\n    public void playLevel(Level level) {\r\n        level.spawnPlayer(1,1);\r\n        for (Ghost ghost : ghosts)\r\n            level.spawnGhost(ghost,9,5);\r\n        graphicsEngine().bindScene(level.getScene());\r\n        kernelEngine.start();\r\n    }\r\n\r\n    // GETTERS //\r\n\r\n    public int getTexturesFile() { return textures; }\r\n\r\n    public KernelEngine kernelEngine() { return kernelEngine; }\r\n\r\n    public GraphicsEngine graphicsEngine() { return kernelEngine.getGraphicsEngine(); }\r\n\r\n    public IOEngine ioEngine() { return kernelEngine.getIoEngine(); }\r\n\r\n    public PhysicsEngine physicsEngine() { return kernelEngine.getPhysicsEngine(); }\r\n\r\n    public SoundEngine soundEngine() { return kernelEngine.getSoundEngine(); }\r\n\r\n    public AIEngine aiEngine() { return kernelEngine.getAiEngine(); }\r\n\r\n    public Pacman getPlayer() { return pacman; }\r\n\r\n    public ArrayList<Ghost> getGhosts() { return ghosts; }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/gameplay/Gameplay.java	(revision a2b889051a437f0dabc13e22187e52207ff63aa3)
+++ src/main/java/gameplay/Gameplay.java	(date 1606482643072)
@@ -135,6 +135,8 @@
      * @param ghost fantôme
      */
     protected void updateGhostDirection(Ghost ghost) {
+
+
         PhysicEntity playerPhysic = pacman.getPhysicEntity();
         PhysicEntity ghostPhysic = ghost.getPhysicEntity();
 
@@ -146,16 +148,45 @@
         int xDistance = playerXmiddle - ghostXmiddle;
         int yDistance = playerYmiddle - ghostYmiddle;
 
-        MoveDirection direction;
+        MoveDirection direction = null;
         PhysicEntity entityOnTheWay;
+        PhysicEntity secondEntityOnTheWay;
+
+        //inutiles pour l'instant mais peut etre utilisables plus tard pour faire en sorte que le fantome continue au moins jusqu'a la prochaine intersection
+        if (ghost.isKeepDown()){
+            direction = MoveDirection.DOWN;
+            setEntityNextDirection(ghost,direction);
+            return;
+        }
+
+        if (ghost.isKeepUp()){
+            direction = MoveDirection.UP;
+            setEntityNextDirection(ghost,direction);
+            return;
+        }
+
+        if (ghost.isKeepLeft()){
+            direction = MoveDirection.LEFT;
+            setEntityNextDirection(ghost,direction);
+            return;
+        }
 
+        if (ghost.isKeepRight()){
+            direction = MoveDirection.RIGHT;
+            setEntityNextDirection(ghost,direction);
+            return;
+        }
+
+        //condition finie et commentée pour le up
         if (Math.abs(xDistance) > Math.abs(yDistance)) {
             if (xDistance < 0) {
                 entityOnTheWay = physicsEngine().isSomethingLeftInLine(ghostPhysic,Math.abs(xDistance));
                 if (entityOnTheWay != null){
                     int entityOnTheWayXMiddle = (entityOnTheWay.getX() + entityOnTheWay.getWidth())/2;
                     int xDistanceWithWall =  entityOnTheWayXMiddle - ghostXmiddle;
-                    if ((Math.abs(xDistance) > Math.abs(xDistanceWithWall)) && (Math.abs(xDistanceWithWall) <= (ghostPhysic.getWidth()/2 + entityOnTheWay.getWidth()/2)/2)){ //si la distance entre fantome et pacman est inférieure a la distance entre fantome et mur
+
+                    //a vérifier selon comportement : peut etre a ajouter dans le if (Math.abs(xDistance) > Math.abs(xDistanceWithWall)) &&
+                    if ((Math.abs(xDistanceWithWall) <= (ghostPhysic.getWidth()/2 + entityOnTheWay.getWidth()/2)/2)){ //si la distance entre fantome et pacman est inférieure a la distance entre fantome et mur
                         if (yDistance < 0) direction = MoveDirection.UP;
                         else direction = MoveDirection.DOWN;
                     }
@@ -172,8 +203,8 @@
                 if (entityOnTheWay != null){
                     int entityOnTheWayXMiddle = (entityOnTheWay.getX() + entityOnTheWay.getWidth())/2;
                     int xDistanceWithWall =  entityOnTheWayXMiddle - ghostXmiddle;
-                    if ((Math.abs(xDistance) > Math.abs(xDistanceWithWall)) && (Math.abs(xDistanceWithWall) <= (ghostPhysic.getWidth()/2 + entityOnTheWay.getWidth()/2)/2)){ //si la distance entre fantome et pacman est inférieure a la distance entre fantome et mur
-                        if (yDistance < 0) direction = MoveDirection.UP;
+                    if ((Math.abs(xDistanceWithWall) <= (ghostPhysic.getWidth()/2 + entityOnTheWay.getWidth()/2)/2)){ //si la distance entre fantome et pacman est inférieure a la distance entre fantome et mur
+                        if (yDistance <= 0) direction = MoveDirection.UP;
                         else direction = MoveDirection.DOWN;
                     }
                     else {
@@ -185,19 +216,50 @@
                 }
             }
         } else {
-            if (yDistance < 0) {
+            //si yDistance < 0 signifie que pacman est au dessus du fantome donc on va globalement vouloir aller en haut
+            if (yDistance <= 0) {
+                //on check si une entité va se retrouver a un moment donné ou a un autre sur le chemin
                 entityOnTheWay = physicsEngine().isSomethingUpInLine(ghostPhysic,Math.abs(yDistance));
                 if (entityOnTheWay != null){
+                    //si oui on fait d'autres vérif
+                    // on enregistre la distance entre le fantome et l'entité
                     int entityOnTheWayYMiddle = (entityOnTheWay.getY() + entityOnTheWay.getHeight())/2;
                     int yDistanceWithWall =  entityOnTheWayYMiddle - ghostYmiddle;
-                    if ((Math.abs(yDistance) > Math.abs(yDistanceWithWall)) && (Math.abs(yDistanceWithWall) <= (ghostPhysic.getHeight()/2 + entityOnTheWay.getHeight()/2)/2)){ //si la distance entre fantome et pacman est inférieure a la distance entre fantome et mur
-                        if (xDistance < 0) direction = MoveDirection.LEFT;
-                        else direction = MoveDirection.RIGHT;
+
+                    //on vérifie laquelle des distances entre pacman et le fantome et entre le mur et le fantome est la plus grande
+                    //si le fantome est plus proche du mur que de pacman on entre dans d'autres vérifications
+                    if ((Math.abs(yDistanceWithWall) <= ((ghostPhysic.getHeight()/2 + entityOnTheWay.getHeight()/2)/2))){ //si la distance entre fantome et pacman est inférieure a la distance entre fantome et mur
+                        //si xDistance < 0 signifie que pacman est a gauche du fantome
+                        if (xDistance <= 0){
+                            //on vérifie si il y a encore un mur sur le chemin en allant a gauche (au moins sur la longueur de
+                            // celui qui blogue le passage initialement et si il y en a un pn va donc a droite
+                            secondEntityOnTheWay = physicsEngine().isSomethingLeftInLine(ghostPhysic,Math.abs(entityOnTheWay.getX() + ghostPhysic.getWidth()));
+                            if (secondEntityOnTheWay != null){
+                                direction = MoveDirection.RIGHT;
+                            }
+                            //s'il n'y a pas d'entité on vérifie si on touche le mur de limite
+                            else {
+                                if(entityOnTheWay.getX()- ghostPhysic.getWidth() <= 0){
+                                    //si sur toute la longueur du bloc on va toucher la limite a un moment on va a droite
+                                    //System.out.println("right");
+                                    direction = MoveDirection.RIGHT;
+                                } else {
+                                    direction = MoveDirection.LEFT;
+                                }
+                                //si on a pas décidés d'aller a droite on a gauche
+                            }
+                            //si sur le chemin il n'y a aucun moyen d'aller vers le haut en allant a gauche alors aller a droite
+                        }
+                        else {
+                            //faut tester maitenant quand on est juste en dessous de pacman x distance = 0 et x distance > 0
+                            direction = MoveDirection.RIGHT;
+                        }
                     }
                     else {
                         direction = MoveDirection.UP;
                     }
                 }
+                //s'il n'y a aucune entité sur le chemin on va droit vers pacman
                 else {
                     direction = MoveDirection.UP;
                 }
@@ -207,8 +269,8 @@
                 if (entityOnTheWay != null){
                     int entityOnTheWayYMiddle = (entityOnTheWay.getY() + entityOnTheWay.getHeight())/2;
                     int yDistanceWithWall =  entityOnTheWayYMiddle - ghostYmiddle;
-                    if ((Math.abs(yDistance) > Math.abs(yDistanceWithWall)) && (Math.abs(yDistanceWithWall) <= (ghostPhysic.getHeight()/2 + entityOnTheWay.getHeight()/2)/2)){ //si la distance entre fantome et pacman est inférieure a la distance entre fantome et mur
-                        if (xDistance < 0) direction = MoveDirection.LEFT;
+                    if ((Math.abs(yDistanceWithWall) <= (ghostPhysic.getHeight()/2 + entityOnTheWay.getHeight()/2)/2)){ //si la distance entre fantome et pacman est inférieure a la distance entre fantome et mur
+                        if (xDistance <= 0) direction = MoveDirection.LEFT;
                         else direction = MoveDirection.RIGHT;
                     }
                     else {
Index: src/main/java/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import engines.kernel.Entity;\r\nimport gameplay.Gameplay;\r\nimport gameplay.Ghost;\r\nimport gameplay.Level;\r\n\r\n/**\r\n * Main\r\n */\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        //Gameplay\r\n        Gameplay gameplay = new Gameplay();\r\n\r\n        //Level par défaut\r\n        Level defaultLevel = gameplay.generateLevel(10,10);\r\n\r\n//        Ghost ghost = new Ghost(gameplay);\r\n\r\n//        defaultLevel.addGhost(ghost,9,5);\r\n\r\n//        gameplay.kernelEngine().addEvent(\"test\",() -> {\r\n//            System.out.println(\"collision\");\r\n//        });\r\n\r\n        //Génération des murs\r\n        for (int j = 0; j < 6; j++) {\r\n            Entity wall = defaultLevel.getMatrix()[5][j];\r\n            gameplay.graphicsEngine().bindColor(wall.getGraphicEntity(),0,0,255);\r\n            gameplay.physicsEngine().addCollisions(gameplay.getPlayer().getPhysicEntity(), wall.getPhysicEntity());\r\n            for (Ghost ghost : gameplay.getGhosts())\r\n                gameplay.physicsEngine().addCollisions(ghost.getPhysicEntity(), wall.getPhysicEntity());\r\n        }\r\n\r\n//        gameplay.physicsEngine().bindEventOnCollision(ghost.getPhysicEntity(), \"test\");\r\n\r\n//        //Génération des boules\r\n//        for (int j = 0; j < 6; j++) {\r\n//            Entity ball = defaultLevel.getMatrix()[6][j];\r\n//            gameplay.graphicsEngine().bindTexture(ball.getGraphicEntity(),gameplay.getTexturesFile(),10,2);\r\n//            gameplay.kernelEngine().addEvent(\"eraseBall\" + j,() -> {\r\n//                gameplay.kernelEngine().removeEntity(ball);\r\n//                gameplay.soundEngine().playSound(\"munch\");\r\n//            });\r\n//            gameplay.physicsEngine().bindEventOnSameLocation(gameplay.getPlayer().getPhysicEntity(), ball.getPhysicEntity(), \"eraseBall\" + j);\r\n//        }\r\n\r\n        gameplay.playLevel(defaultLevel);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/Main.java	(revision a2b889051a437f0dabc13e22187e52207ff63aa3)
+++ src/main/java/Main.java	(date 1606481730366)
@@ -31,6 +31,14 @@
                 gameplay.physicsEngine().addCollisions(ghost.getPhysicEntity(), wall.getPhysicEntity());
         }
 
+        for (int j = 0; j < 2; j++) {
+            Entity wall = defaultLevel.getMatrix()[j+5][3];
+            gameplay.graphicsEngine().bindColor(wall.getGraphicEntity(),0,0,255);
+            gameplay.physicsEngine().addCollisions(gameplay.getPlayer().getPhysicEntity(), wall.getPhysicEntity());
+            for (Ghost ghost : gameplay.getGhosts())
+                gameplay.physicsEngine().addCollisions(ghost.getPhysicEntity(), wall.getPhysicEntity());
+        }
+
 //        gameplay.physicsEngine().bindEventOnCollision(ghost.getPhysicEntity(), "test");
 
 //        //Génération des boules
